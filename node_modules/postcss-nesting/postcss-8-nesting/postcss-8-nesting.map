{
  "version": 3,
  "sources": ["../src/lib/shift-nodes-before-parent.js", "../src/lib/cleanup-parent.js", "../src/lib/valid-selector.js", "../src/lib/merge-selectors.js", "../src/lib/rule-within-rule.js", "../src/lib/list.js", "../src/lib/nest-rule-within-rule.js", "../src/lib/valid-atrules.js", "../src/lib/atrule-within-rule.js", "../src/lib/merge-params.js", "../src/lib/atrule-within-atrule.js", "../src/lib/walk.js", "../src/postcss-8-nesting.js"],
  "sourcesContent": ["export default function shiftNodesBeforeParent(node) {\n\tconst parent = node.parent\n\tconst index = parent.index(node)\n\n\t// conditionally move previous siblings into a clone of the parent\n\tif (index) {\n\t\tparent.cloneBefore().removeAll().append(parent.nodes.slice(0, index))\n\t}\n\n\t// move the current node before the parent (and after the conditional clone)\n\tparent.before(node)\n\n\treturn parent\n}\n", "export default function cleanupParent(parent) {\n\tif (!parent.nodes.length) {\n\t\tparent.remove()\n\t}\n}\n", "// a valid selector is an ampersand followed by a non-word character or nothing\nexport default /&(?:[^\\w-|]|$)/\n\nexport const complex = /&[^]*&/\n\nexport const replaceable = /&/g\n\n", "import { complex, replaceable } from './valid-selector.js'\n\nexport default function mergeSelectors(fromSelectors, toSelectors) {\n\treturn fromSelectors.reduce(\n\t\t(selectors, fromSelector) => selectors.concat(\n\t\t\ttoSelectors.map(\n\t\t\t\t(toSelector) => complex.test(toSelector)\n\t\t\t\t\t? toSelector.replace(replaceable, `:is(${fromSelector})`)\n\t\t\t\t: toSelector.replace(replaceable, fromSelector)\n\t\t\t)\n\t\t),\n\t\t[]\n\t)\n}\n", "import shiftNodesBeforeParent from './shift-nodes-before-parent.js'\nimport cleanupParent from './cleanup-parent.js'\nimport mergeSelectors from './merge-selectors.js'\nimport validSelector from './valid-selector.js'\n\nexport default function transformRuleWithinRule(node) {\n\t// move previous siblings and the node to before the parent\n\tconst parent = shiftNodesBeforeParent(node)\n\n\t// update the selectors of the node to be merged with the parent\n\tnode.selectors = mergeSelectors(parent.selectors, node.selectors)\n\n\t// merge similar rules back together\n\tconst areSameRule = (node.type === 'rule' && parent.type === 'rule' && node.selector === parent.selector) || (node.type === 'atrule' && parent.type === 'atrule' && node.params === parent.params)\n\n\tif (areSameRule) {\n\t\tnode.append(...parent.nodes)\n\t}\n\n\t// conditionally cleanup an empty parent rule\n\tcleanupParent(parent)\n}\n\nexport const isRuleWithinRule = (node) => node.type === 'rule' && Object(node.parent).type === 'rule' && node.selectors.every((selector) => selector.trim().lastIndexOf('&') === 0 && validSelector.test(selector))\n", "export const split = (string, separators, last) => {\n\tlet array = []\n\tlet current = ''\n\tlet split = false\n\n\tlet func = 0\n\tlet quote = false\n\tlet escape = false\n\n\tfor (let letter of string) {\n\t\tif (escape) {\n\t\t\tescape = false\n\t\t} else if (letter === '\\\\') {\n\t\t\tescape = true\n\t\t} else if (quote) {\n\t\t\tif (letter === quote) {\n\t\t\t\tquote = false\n\t\t\t}\n\t\t} else if (letter === '\"' || letter === \"'\") {\n\t\t\tquote = letter\n\t\t} else if (letter === '(') {\n\t\t\tfunc += 1\n\t\t} else if (letter === ')') {\n\t\t\tif (func > 0) func -= 1\n\t\t} else if (func === 0) {\n\t\t\tif (separators.includes(letter)) split = true\n\t\t}\n\n\t\tif (split) {\n\t\t\tif (current !== '') array.push(current.trim())\n\t\t\tcurrent = ''\n\t\t\tsplit = false\n\t\t} else {\n\t\t\tcurrent += letter\n\t\t}\n\t}\n\n\tif (last || current !== '') array.push(current.trim())\n\treturn array\n}\n\nexport const comma = (string) => split(string, [','], true)\n\nexport const space = (string) => split(string, [' ', '\\n', '\\t'])\n", "import { comma } from './list.js'\nimport shiftNodesBeforeParent from './shift-nodes-before-parent.js'\nimport cleanupParent from './cleanup-parent.js'\nimport mergeSelectors from './merge-selectors.js'\nimport validSelector from './valid-selector.js'\nimport walk from './walk.js'\n\nexport default function transformNestRuleWithinRule(node) {\n\t// move previous siblings and the node to before the parent\n\tconst parent = shiftNodesBeforeParent(node)\n\n\t// clone the parent as a new rule with children appended to it\n\tconst rule = parent.clone().removeAll().append(node.nodes)\n\n\t// replace the node with the new rule\n\tnode.replaceWith(rule)\n\n\t// update the selectors of the node to be merged with the parent\n\trule.selectors = mergeSelectors(parent.selectors, comma(node.params))\n\n\t// conditionally cleanup an empty parent rule\n\tcleanupParent(parent)\n\n\t// walk the children of the new rule\n\twalk(rule)\n}\n\nexport const isNestRuleWithinRule = (node) => node.type === 'atrule' && node.name === 'nest' && Object(node.parent).type === 'rule' && comma(node.params).every((selector) => selector.split('&').length >= 2 && validSelector.test(selector))\n", "export default ['container', 'document', 'media', 'supports']\n", "import cleanupParent from './cleanup-parent.js'\nimport shiftNodesBeforeParent from './shift-nodes-before-parent.js'\nimport validAtrules from './valid-atrules.js'\nimport walk from './walk.js'\n\n/*\n * DEPRECATED: In v7.0.0 these features will be removed as they are not part of\n * the nesting proposal.\n */\n\nexport default function atruleWithinRule(node) {\n\t// move previous siblings and the node to before the parent\n\tconst parent = shiftNodesBeforeParent(node)\n\n\t// clone the parent as a new rule with children appended to it\n\tconst rule = parent.clone().removeAll().append(node.nodes)\n\n\t// append the new rule to the node\n\tnode.append(rule)\n\n\t// conditionally cleanup an empty parent rule\n\tcleanupParent(parent)\n\n\t// walk the children of the new rule\n\twalk(rule)\n}\n\nexport const isAtruleWithinRule = (node) => node.type === 'atrule' && validAtrules.includes(node.name) && Object(node.parent).type === 'rule'\n", "import { comma } from './list.js'\n\nexport default function mergeParams(fromParams, toParams) {\n\treturn comma(fromParams)\n\t\t.map((params1) =>\n\t\t\tcomma(toParams)\n\t\t\t\t.map((params2) => `${params1} and ${params2}`)\n\t\t\t\t.join(', '),\n\t\t)\n\t\t.join(', ')\n}\n", "import cleanupParent from './cleanup-parent.js'\nimport mergeParams from './merge-params.js'\nimport shiftNodesBeforeParent from './shift-nodes-before-parent.js'\nimport validAtrules from './valid-atrules.js'\n\n/*\n * DEPRECATED: In v7.0.0 these features will be removed as they are not part of\n * the nesting proposal.\n */\n\nexport default function transformAtruleWithinAtrule(node) {\n\t// move previous siblings and the node to before the parent\n\tconst parent = shiftNodesBeforeParent(node)\n\n\t// update the params of the node to be merged with the parent\n\tnode.params = mergeParams(parent.params, node.params)\n\n\t// conditionally cleanup an empty parent rule\n\tcleanupParent(parent)\n}\n\nexport const isAtruleWithinAtrule = (node) => node.type === 'atrule' && validAtrules.includes(node.name) && Object(node.parent).type === 'atrule' && node.name === node.parent.name\n", "import transformRuleWithinRule, { isRuleWithinRule } from './rule-within-rule.js'\nimport transformNestRuleWithinRule, { isNestRuleWithinRule } from './nest-rule-within-rule.js'\nimport transformAtruleWithinRule, { isAtruleWithinRule } from './atrule-within-rule.js'\nimport transformAtruleWithinAtrule, { isAtruleWithinAtrule } from './atrule-within-atrule.js'\n\nexport default function walk(node) {\n\tnode.nodes.slice(0).forEach((child) => {\n\t\tif (child.parent === node) {\n\t\t\tif (isRuleWithinRule(child)) {\n\t\t\t\ttransformRuleWithinRule(child)\n\t\t\t} else if (isNestRuleWithinRule(child)) {\n\t\t\t\ttransformNestRuleWithinRule(child)\n\t\t\t} else if (isAtruleWithinRule(child)) {\n\t\t\t\ttransformAtruleWithinRule(child)\n\t\t\t} else if (isAtruleWithinAtrule(child)) {\n\t\t\t\ttransformAtruleWithinAtrule(child)\n\t\t\t}\n\n\t\t\tif (Object(child.nodes).length) {\n\t\t\t\twalk(child)\n\t\t\t}\n\t\t}\n\t})\n}\n", "import walk from './lib/walk.js'\n\nexport default function postcssNesting() {\n\treturn {\n\t\tpostcssPlugin: 'postcss-nesting',\n\t\tOnce(root) {\n\t\t\twalk(root)\n\t\t},\n\t}\n}\n\npostcssNesting.postcss = true\n"],
  "mappings": "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",
  "names": []
}
